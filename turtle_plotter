#!/usr/bin/python3
"""
simple 2D turtle plotter interprets symbols received from stdin.
"""
__author__  = "Josef Kubin"
__date__    = "2018/07/24"
__email__   = "Base64: bTR1bml4QGdtYWlsLmNvbQ"
__status__  = "Dev"
__license__ = "GPL"
__version__ = "0.9.0"

#import os
#import system

import sys
import json
import argparse
import textwrap
import turtle as tu

parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=textwrap.dedent('''\
                2D turtle plotter interprets symbols of turtle graphic received from stdin.
                The first received line serves as a turtle plotter configuration.
                The second received line contains symbols for turtle plotter.

                The plotter recognizes the following symbols:
                '+': turn to the left
                '-': turn to the right
                'F': draw line
                'Z': draw line of a half step
                'R': draw red line (non standard)
                'G': draw green line (non standard)
                'B': draw blue line (non standard)
                'R': draw brown line (non standard)
                'M': draw magenta line (non standard)
                'f': move pen (no line)
                'z': move pen (no line) half step
                '[': push the current turtle state on the stack to remember angle and position
                '|': reverse direction (turn back 180°)
                ']': pop a state from the stack and adjust angle and position

                Example:
                "title":"Sierpiński triangle", "turtle": "tkinter", "angle":120, "step":20, "penw":2, "bend":0, "setx":-300, "sety":-200, "seth":60, "width":1.0, "height":1.0
                F-F+F+F-F-FF+F-F+F+F-F+FF-F-F+F+F-F-FFFF-FFFF

                ---
                Keyboard shortcuts for interactive mode:
                'k': faster
                'j': slower
                'f': finish
                'q/Enter/ESC': exit
                '''))

parser.add_argument("-i", "--interactive",
        help="keyboard control",
        action="store_true")

args = parser.parse_args()
stack_angle = []
stack_position = []
stack_step = []
stack_width = []
stack_float_step = []
slow  = 1000

# the first line contains the configuration of the turtle
cfg = json.loads('{' + sys.stdin.readline() + '"end":""}')

if 'turtle' in cfg:
    if cfg['turtle'] != 'tkinter':
        sys.exit("unknown \"turtle\":\"" + cfg['turtle'] + "\" (\"tkinter\" expected)")

if 'step' in cfg:
    step = float(cfg['step'])
    float_step = float(step)
else:
    sys.exit("\"step\" in the turtle configuration is mandatory")

if 'width' in cfg:
    window_width = float(cfg['width'])
else:
    window_width = 1.0

if 'height' in cfg:
    window_height = float(cfg['height'])
else:
    window_height = 1.0

tu.setup(width = window_width, height = window_height)

tu.hideturtle()

if 'seth' in cfg:
    tu.seth(float(cfg['seth']))
else:
    tu.seth(0)

tu.title(cfg['title'])
tu.penup()

if 'setx' in cfg:
    setx = float(cfg['setx'])
else:
    setx = 0

if 'sety' in cfg:
    sety = float(cfg['sety'])
else:
    sety = 0

tu.setpos(setx, sety)

if args.interactive:
    tu.speed(5)
    tu.showturtle()
else:
    tu.tracer(0)

tu.pendown()

if 'angle' in cfg:
    angle = float(cfg['angle'])
else:
    angle = 90

if 'bend' in cfg:
    bend = float(cfg['bend'])
else:
    bend = 0

if 'penw' in cfg:
    tu.width(int(cfg['penw']))

if 'scale' in cfg:
    scale = float(cfg['scale'])
else:
    scale = 0

def exit():
    tu.bye()

def faster_turtle():
    if tu.speed() < 9:
        tu.speed(tu.speed() + 1)
        tu.delay(tu.delay() + 10)

def slower_turtle():
    if tu.speed() > 1:
        tu.speed(tu.speed() - 1)
        tu.delay(tu.delay() - 10)

def pause_turtle():
    if tu.delay() == 1000:
        tu.delay(tu.xxx)
    else:
        tu.xxx = tu.delay()
        tu.delay(1000)

def finish_turtle():
    tu.tracer(0)
    tu.hideturtle()

tu.listen()

tu.onkey(exit, "Return")
tu.onkey(exit, "Escape")
tu.onkey(exit, "q")
tu.onkey(faster_turtle, "k")
tu.onkey(slower_turtle, "j")
tu.onkey(pause_turtle, " ")
tu.onkey(finish_turtle, "f")
#tu.exitonclick()

#tu.Screen().onkey(pause_turtle, " ")

def right():
    tu.right(angle + bend)

def left():
    tu.left(angle - bend)

def incr_width():
    tu.width(tu.width() + 1)

def decr_width():
    tu.width(tu.width() - 1)

def reverse_direction():
    tu.right(180)

def write_line_black():
    tu.right(bend)
    tu.pencolor('black')
    tu.forward(step)

def write_line_half():
    tu.right(bend)
    tu.pencolor('black')
    tu.forward(step/2)

def write_line_red():
    tu.right(bend)
    tu.pencolor('red')
    tu.forward(step)

def write_line_green():
    tu.right(bend)
    tu.pencolor('green')
    tu.forward(step)

def write_line_blue():
    tu.right(bend)
    tu.pencolor('blue')
    tu.forward(step)

def write_line_brown():
    tu.right(bend)
    tu.pencolor('brown')
    tu.forward(step)

def write_line_magenta():
    tu.right(bend)
    tu.pencolor('magenta')
    tu.forward(step)

def move_pen():
    tu.penup()
    tu.forward(step)
    tu.pendown()

def move_pen_half():
    tu.penup()
    tu.forward(step/2)
    tu.pendown()

def push_node():
    stack_angle.append(tu.heading())
    stack_position.append(tu.position())
    stack_width.append(tu.width())
    stack_float_step.append(float_step)
    stack_step.append(step)

def pop_node():
    tu.penup()
    tu.setheading(stack_angle.pop())
    tu.setposition(stack_position.pop())
    tu.width(stack_width.pop())

    global float_step, step
    float_step = stack_float_step.pop()
    step = stack_step.pop()

    tu.pendown()

def extend_line():
    global float_step, step
    float_step *= scale
    step = round(float_step)

def shrink_line():
    global float_step, step
    float_step /= scale
    step = round(float_step)

def update():
    tu.update()
    tu.hideturtle()

growing_rules = {
        "+":left,
        "-":right,
        "F":write_line_black,
        "Z":write_line_half,
        "R":write_line_red,
        "G":write_line_green,
        "B":write_line_blue,
        "R":write_line_brown,
        "M":write_line_magenta,
        "f":move_pen,
        "z":move_pen_half,
        "[":push_node,
        "|":reverse_direction,
        "]":pop_node,
        ">":extend_line,
        "<":shrink_line,
        "#":incr_width,
        "!":decr_width,
        "\n":update
        }

for b in sys.stdin.readline():
    growing_rules[b]()

tu.done()
